package gitlab

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"net/http"
	"os"
	"path"
	"path/filepath"
	"strings"

	gl "gitlab.com/gitlab-org/api/client-go"
)

// DriftMRResult holds the outcome of the MR creation/update workflow.
type DriftMRResult struct {
	WebURL  string
	Created bool // true = new MR, false = existing MR updated
}

// GetDefaultBranch returns the default branch for the given project.
// Falls back to "main" if the project has no default branch configured.
func (c *Client) GetDefaultBranch(ctx context.Context, project string) (string, error) {
	p, _, err := c.api.Projects.GetProject(project, nil, gl.WithContext(ctx))
	if err != nil {
		return "", fmt.Errorf("getting project %s: %w", project, err)
	}
	if p.DefaultBranch == "" {
		return "main", nil
	}
	return p.DefaultBranch, nil
}

// FindExistingDriftMR searches for an open MR with a "drift/" source branch prefix.
// Returns nil, nil if no matching MR is found.
func (c *Client) FindExistingDriftMR(ctx context.Context, project string) (*gl.BasicMergeRequest, error) {
	opts := &gl.ListProjectMergeRequestsOptions{
		State:       gl.Ptr("opened"),
		ListOptions: gl.ListOptions{PerPage: 100},
	}

	for {
		mrs, resp, err := c.api.MergeRequests.ListProjectMergeRequests(project, opts, gl.WithContext(ctx))
		if err != nil {
			return nil, fmt.Errorf("listing merge requests for %s: %w", project, err)
		}
		for _, mr := range mrs {
			if strings.HasPrefix(mr.SourceBranch, "drift/") {
				return mr, nil
			}
		}
		if resp.NextPage == 0 {
			break
		}
		opts.Page = resp.NextPage
	}

	return nil, nil
}

// EnsureBranch creates the branch if it does not already exist.
func (c *Client) EnsureBranch(ctx context.Context, project, branchName, defaultBranch string) error {
	_, _, err := c.api.Branches.GetBranch(project, branchName, gl.WithContext(ctx))
	if err == nil {
		return nil
	}

	var errResp *gl.ErrorResponse
	if !errors.As(err, &errResp) || errResp.Response.StatusCode != http.StatusNotFound {
		return fmt.Errorf("checking branch %s: %w", branchName, err)
	}

	_, _, err = c.api.Branches.CreateBranch(project, &gl.CreateBranchOptions{
		Branch: gl.Ptr(branchName),
		Ref:    gl.Ptr(defaultBranch),
	}, gl.WithContext(ctx))
	if err != nil {
		return fmt.Errorf("creating branch %s: %w", branchName, err)
	}

	return nil
}

// CommitDriftFiles commits generated .tf files to the given branch.
// Returns true if a commit was created, false if all files are identical.
func (c *Client) CommitDriftFiles(ctx context.Context, project, branchName, generatedDir, repoPath string) (bool, error) {
	files, err := filepath.Glob(filepath.Join(generatedDir, "*.tf"))
	if err != nil {
		return false, fmt.Errorf("listing generated files: %w", err)
	}
	if len(files) == 0 {
		return false, nil
	}

	var actions []*gl.CommitActionOptions

	for _, f := range files {
		localContent, err := os.ReadFile(f)
		if err != nil {
			return false, fmt.Errorf("reading file %s: %w", f, err)
		}

		remotePath := filepath.Base(f)
		if repoPath != "" {
			remotePath = path.Join(repoPath, remotePath)
		}

		existing, _, err := c.api.RepositoryFiles.GetRawFile(project, remotePath, &gl.GetRawFileOptions{
			Ref: gl.Ptr(branchName),
		}, gl.WithContext(ctx))

		if err != nil {
			var errResp *gl.ErrorResponse
			if errors.As(err, &errResp) && errResp.Response.StatusCode == http.StatusNotFound {
				actions = append(actions, &gl.CommitActionOptions{
					Action:   gl.Ptr(gl.FileCreate),
					FilePath: gl.Ptr(remotePath),
					Content:  gl.Ptr(string(localContent)),
				})
				continue
			}
			return false, fmt.Errorf("checking remote file %s: %w", remotePath, err)
		}

		if !bytes.Equal(existing, localContent) {
			actions = append(actions, &gl.CommitActionOptions{
				Action:   gl.Ptr(gl.FileUpdate),
				FilePath: gl.Ptr(remotePath),
				Content:  gl.Ptr(string(localContent)),
			})
		}
	}

	if len(actions) == 0 {
		return false, nil
	}

	_, _, err = c.api.Commits.CreateCommit(project, &gl.CreateCommitOptions{
		Branch:        gl.Ptr(branchName),
		CommitMessage: gl.Ptr("chore: update Terraform resources from GitLab drift scan"),
		Actions:       actions,
	}, gl.WithContext(ctx))
	if err != nil {
		return false, fmt.Errorf("creating commit: %w", err)
	}

	return true, nil
}

// CreateDriftMR creates a new merge request for the drift branch.
func (c *Client) CreateDriftMR(ctx context.Context, project, branchName, defaultBranch string) (*gl.MergeRequest, error) {
	mr, _, err := c.api.MergeRequests.CreateMergeRequest(project, &gl.CreateMergeRequestOptions{
		Title:              gl.Ptr("chore: update Terraform resources from GitLab drift scan"),
		SourceBranch:       gl.Ptr(branchName),
		TargetBranch:       gl.Ptr(defaultBranch),
		RemoveSourceBranch: gl.Ptr(true),
		Description:        gl.Ptr("Auto-generated by [terraform-gitlab-drift](https://github.com/xMoelletschi/terraform-gitlab-drift)."),
	}, gl.WithContext(ctx))
	if err != nil {
		return nil, fmt.Errorf("creating merge request: %w", err)
	}
	return mr, nil
}
